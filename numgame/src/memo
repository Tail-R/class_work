--- 数独プログラム ---

* 重要な関数たち
    backtrack(&mat, n)
    	深さ優先探索で数独を解く。
    
    	update_board(&mat)
    		候補管理領域を見て手詰まりになるまで盤面を更新する。
    		
    			update_cell(&mat, x, y) -> bool
    				候補管理領域を見てマス目を更新する。
    				
    			h_check(&mat, x, y, val)
    				水平に候補管理領域にチェックを打つ。
    			
    			v_check(&mat, x, y, val)
    				垂直に候補管理領域にチェックを打つ。
    	
    			block_check(&mat, x, y, base_x, base_y, val)
    				ブロック状に候補管理領域にチェックを打つ。

* ステップ１
	与えられた盤面に update_board をかける
	
* ステップ 2
	backtrack で盤面を走査し、未定のマスを見つけるたびに１から
    順に数字を試す。
	
    候補管理領域を見てゲームのルールに違反していなければ
    仮決めをする。
		
	仮決めをしたら、仮盤面に update_board をかけて再帰的に
    関数を呼び出す。
    

--- Nの決め方の改良 ---
前回はすべてのセルを走査してセルの先頭に0 ~ NNがあれば
無視して次を呼び出す、0(未定)であればバックトラック用の処理をする。
ということをしていたが、わざわざ分岐をしなくても0のところだけに着目
してバックトラックすれば良いということで、盤面から次のnを決める処理を
next_nという外部の関数にすることにしました。

next_n(&mat)
	盤面を表現している３次元の配列を受け取る。左上から右下まで勝ち残り
	作戦で最も候補管理領域が削られているセル
































		
		
		
